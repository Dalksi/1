<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Архитектура  </title>
    <link href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="index.css">
  </head>
   <body>

<div class="wrapper">
    <div class="top_line">
        <nav class="header_Zagolovok">
        <h1><a href="index.html">Архитектура</a></h1>
    </nav>

        <nav class="header_nav">
            <ul style="list-style: none;">
                <li class="active"><a href="index.html">Главная</a></li>
                <li class="active"><a href="IspCode.html">Исполнение кода</a></li>
            </ul >
        </nav>
    </div>
    <div class="bottom_ARH">
        <p>Современные микропроцессоры Эльбрус базируются на <br>
            архитектуре E2K, в основе которой лежит подход VLIW</p>
            <div class="bottom_foto">
            <p><img src="Tabl.png" width="700" height="500">
   <figcaption>
    Скриншот 1. Различие архитектур CISC (x86), RISC (ARM), и VLIW (E2K).
   </figcaption>
</div></p>
<p> CISC (x86) архитектура от RISC (ARM) отличается шириной командного слова:<br>
в RISC (ARM) команды короткие и имеют фикс. размер, а в CISC (x86) ширина команды уже не фиксирована, но может быть длиннее.<br> <br>
VLIW больше похоже на RISC, нежели на CISC, т.к., хоть команды и шире намного, чем даже в CISC, но у VLIW ширина команд фиксирована.<br><br>
С 1995 года x86 программы подают процессору x86 команды, но затем процессоры разбивают эти команды на RISC-подобные микрооперации.<br><br>
Снаружи у Intel и AMD – CISC, а внутри – RISC.<br><br>
Но зачем было так делать в 95-м?<br><br>
Причина в том, что с годами количество транзисторов и вычислительных блоков росло, но было неясно, а как их задействовать то. <br><br>
Intel и AMD нужно было как-то распараллелить операции для того, чтобы вычисления задействовали больше вычислительных устройств.<br><br>
Вот и стали одну x86 (CISC) команду делить на (максимум) 4 RISC-подобные микрооперации. <br><br>
Одна команда теперь стала грузить не один большой вычислительный блок, а вплоть до 4 мелких.<br><br>
Но почему Эльбрус тогда использует VLIW?<br><br>
Ведь Intel и AMD оказалось проще засунуть RISC блоки внутрь своих x86 процессоров, и заставить CISC команды разбиваться на RISC команды, чтобы добиться повышения производительности.<br><br>
Разве это не значит, что если уж CISC не подошёл, то и с VLIW будет то же самое?<br><br>
Разве он сможет в параллелизм?<br><br>
Тут, как выяснилось, дело не в том, что широкое (CISC) и очень широкое (VLIW) команды не эффективны, а в том, что оптимизировать код для задействования всех возможностей процессора крайне сложно.<br><br>
Если у вас одна команда дробится, условно, на 4 микрооперации, вы уже можете занять до 4 раз больше ресурсов для выполнения этой одной команды, если правильно свой код организуете.<br><br>
Задача по оптимизации кода у x86 процессора лежит на самом 
процессоре:<br> насколько эффективно процессор декодирует эти инструкции, и 
насколько эффективно он распределит задачу по ядрам – большой вопрос.<br><br> 
x86 (CISC) процессоры Intel и AMD разбивают относительно 
небольшое количество CISC команд на огромное количество RISC команд, 
которые могут исполняться параллельно.<br><br> Т.е. вместо того, чтобы по одному 
последовательно выполнять большие входящие команды, процессоры Intel и 
AMD разбивают эти команды на RISC-подобные микрооперации и 
выполняют сразу несколько команд параллельно маленькими арифметико-
логическими устройствами (ALU).<br><br> То, что я сейчас описал, зовётся 
superscalar (суперскалярным процессором).<br><br> И этот вид параллелизма зовётся 
неявным параллелизмом.<br><br> Почему неявным?<br><br> 
Дело в том, что, вместо того, чтобы изначально давать процессору уже распараллеленный код, мы даём 
ядрам процессора простые команды, а дальше они уже сам решает, сколько
своих ALU им задействовать (в рамках каждого из ядер).<br><br>
Но даже с таким подходом наращивать производительность бесконечно 
не выходит ни у Intel, ни у AMD.<br><br> Для начала, разбивать большие CISC (x86) 
команды можно лишь не более чем на 4 маленькие RISC команды.<br><br> Почему 
максимум 4?<br><br> Дело в том, что иначе 
обратную совместимость с предыдущими процессорами x86 не обеспечить.<br><br> 
Да, с каждым годом всё больше и больше транзисторов задействуется в 
процессорах Intel и AMD, но им постоянно приходится идти на ухищрения 
для роста производительности, т.к.<br><br> больше параллелизма им со старым 
подходом не выжать.<br><br> Поэтому в 2002-м году свет увидели процессоры Intel
Pentium 4, которые первыми на потребительском рынке получили поддержку 
виртуальной многоядерности или многопоточности, которую назвали Intel
Hyper-Threading (ранее эта технология появилась в процессорах серии Intel
Xeon).<br><br> Суть этой технологии в том, что ядро физически у вас одно, но 
система его видит как 2 разных ядра, и ваши программы работают с одним 
ядром так, словно их 2.<br><br> И, если ранее программы не могли задействовать все 
вычислительные возможности каждого из ядер процессора, то теперь они на 
каждом ядре старались задействовать больше АЛУ (до 2 раз больше).
<p><img src="Hyper.png" width="700" height="400">
    <figcaption>
        Скриншот 2. Разница между физическими ядрами и виртуальными.
    </figcaption>
 </div></p><br></p>
        <ul class="flex">
         
        </ul>
    </div>
</div>
</header>

<footer class="footer">
<div class="wrapper">
    <nav class="header_novichek">
        <ul style="list-style: none;">
            <li><a href="http://www.mcst.ru/" target="_blank">Оф. страница МЦСТ</a></li>
            <li><a href="mailto:mcst@mcst.ru">Почта</a></li>
        </ul>
    </nav>
</div>

</body>
</html>

<!--.
⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠰⣤⣤⢀
⠄⠄⠄⠄⠄⠄⠄⣀⣀⣀⠄⠄⢿⣿⣦⠈⢄
⠄⠄⠄⠄⠄⠈⠻⣿⣶⣦⣍⠐⢼⣿⣿⣧⠈⡄
⠄⠄⠄⠄⠄⠄⠄⠈⢿⣿⣿⣷⣄⣿⣿⣿⣦⣴⣦⣀
⠄⠄⠄⠄⢀⢠⣄⣒⣚⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡧⠄
⠄⠄⠄⠰⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡧⣤⣤⣤⣄⡀
⠄⠄⠄⠄⠄⠄⠉⠻⢿⣿⣿⣿⡽⣿⠟⢃⣿⠟⡉⣿⣿⣿⣿⣿⠿⠛⠉
⠄⠄⠄⠄⠄⠠⠶⢯⣭⣿⢹⡟⢶⣗⠄⢸⠇⢁⣠⠫⠟⣹⣿⣯⡭⠶⠂
⠄⠄⠄⠄⠄⠄⠄⠄⠈⢙⣄⠣⠁⠈⠓⠊⠐⠃⠄⠄⣰⣿⣏⡀
⠄⠄⠄⠄⠄⠄⠄⠄⠄⠉⢉⣽⠄⠄⠄⠄⠄⠄⠄⣿⣯⠉⠉
⠄⠄⠄⠄⠄⠄⠄⠄⠄⣠⣿⣿⡀⠄⠄⠄⠄⠄⠄⣿⣿⣷⡀
⠄⠄⠄⠄⠄⠄⢀⣴⣾⣿⣿⣿⣷⡀⠄⠄⠄⠄⢠⣿⣿⣿⣷⣦⣄⡀
⠄⠄⠄⠄⣰⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀
⠄⠄⢀⠘⢛⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⢿⣿⣿⣿⠗⠄
⠄⢀⣧⣀⡀⠶⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣏⣠⣀⣀⣿⡿⠃⢢⣠⡆
⠄⢸⠿⣿⡿⣷⡿⠿⣿⢿⡿⠩⢹⣿⡟⠉⠉⠉⢹⣿⢻⠛⠛⠻⢿⣿⣷⣿⣿⠉⠟
⠄⡾⢶⣿⣦⣿⣷⡇⢁⠚⡇⠐⢀⣿⣷⣤⣤⣤⣿⣧⣀⣠⣇⡰⢀⡿⣿⣿⣷⣾⣶⡀
⢰⣵⡎⠹⣿⣿⣿⣁⣾⢻⣿⢻⣟⣩⣿⣿⣿⣿⣿⣿⣿⣿⣿⣥⣾⣿⡿⠛⠛⢛⡟⢇
⣾⣿⣞⣰⠞⣩⣿⣻⡇⢠⠃⠸⠉⠙⣿⣿⣿⣿⢈⡁⠤⠁⠌⢉⢙⣿⣐⣧⣤⣾⢇⢸
⢹⡿⢿⢋⡍⢇⠛⣿⣧⣼⣦⣴⣔⣠⣿⣿⣿⣯⣦⣤⣦⣤⣦⣄⣸⡻⢛⠋⠉⠻⠿⡇
⠄⡰⠄⣆⣷⣴⣶⠿⣿⡿⣿⢿⣿⣿⣿⣿⣿⢿⡿⢿⣿⢉⠉⣿⣿⣷⣾⣤⣭⡁⠂⠄
⠄⢱⣾⣿⣿⣿⣿⠐⣉⣌⠇⠐⠁⡄⣿⣿⣿⠈⡠⢾⡇⠠⠠⣼⣽⡟⢣⠄⣹⣿⡖
⠄⠄⢿⣉⠁⣿⣷⣿⡟⢿⡵⣾⣶⣦⣿⣿⣿⣴⣷⣾⣷⠖⡴⠿⣿⣿⠷⠚⢛⡻⠁
⠄⠄⠈⢿⣆⣿⣿⣿⣧⠐⡅⢘⠃⣿⣿⣿⣟⠿⡿⣿⣧⣈⠴⢃⠘⣻⣿⣿⡟
⠄⠄⠄⢰⢻⣿⠃⢸⣿⣶⣿⡿⡟⢉⣿⢿⣻⣼⣧⠂⠛⢿⣷⣟⣀⣥⡼⠋
⠄⠄⠄⣾⣏⡙⣿⣾⣿⣿⠿⢄⠉⣸⡿⠁⠉⠉⠟⢬⢛⢚⠻⣿⣿⠛
⠄⠄⠄⣿⣷⣦⣅⣙⣿⣧⣮⣬⣽⡟⠄⠄⠄⠄⢶⣶⣮⢧⢠⠙⣰⢹⣦
⠄⠄⠄⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⡀⠄⠄⠄⠄⠄⣈⣽⣶⣿⣿⣷⣼⠟⠆
⠄⠄⠄⠘⢥⣏⢿⢯⣿⡟⠄⣿⣿⣿⣶⣄⣠⢈⠲⠟⣛⠏⣍⣏⠬⣄⡺
⠄⠄⠄⠄⢸⣿⣿⣾⣿⣃⣧⣿⣿⣿⣿⣿⣧⣒⣴⣦⣾⣶⣾⣶⣿⡇-->